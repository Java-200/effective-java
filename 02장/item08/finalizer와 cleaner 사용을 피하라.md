### 객체 소멸자 finalizer
예측할 수 없고 상황에 따라 위험할 수 있어 일반적으로 불필요하다. (deprecated API)

### cleaner 
finalizer 보다는 덜 위험하지만, 여전히 예측 불가하고 느리고 불필요하다.

## 단점
### 1. finalizer와 cleaner는 즉시 수행된다는 보장이 없다.
finalizer와 cleaner로 제때 실행되어야 하는 작업은 절대 할 수 없다.
ex) 시스템에서 동시에 파일 여는 개수 제한되어있어 새로운 파일을 열지 못하는 상황이 발생할 수 있다.

### 2. 얼마나 신속하게 수행할지 알 수 없다.
finalizer와 cleaner가 얼마나 빠르게 수행될지는 전적으로 가비지 컬렉터 알고리즘에 달렸고, 이는 가비지 컬렉터 마다 천차만별.
테스트한 JVM에선 완벽하게 동작하더라도 고객 시스템에선 재앙을 일으킬 수도 있다.

### 3. 스레드 우선순위가 낮다.
finalizer 스레드는 다른 스레드보다 우선순위가 낮아 실행 기회를 얻지 못할 수 있다. 
따라서, 자원 회수가 지연되어 OutOfMemoryError 내며 죽는 상황이 발생할 수 있다. cleaner는 일부 개선되었지만 즉각적인 수행 보장은 없다.

### 4. finalizer와 cleaner는 실행되지 않을 수도 있다.
수행 여부조차 보장하지 않기 때문에, 상태를 영구적으로 수행하는 작업에서는 절대 의존하면 안됨.
ex) 데이터베이스 같은 공유 자원의 락 해제를 finalizer나 cleaner에 맡기면 분산 시스템 전체가 서서히 멈출 것이다.

### 5. finalizer 동작 중에 예외가 발생하면 정리 작업이 처리되지 않을 수도 있다.
예외 발생 시 자원 반납 안된 채로 그대로 끝날 수 있음

### 6. finalizer와 cleaner는 심각한 성능 문제가 있다.
-> 안전망 형태를 사용하면 빨라지지만, 성능이 느려진다.

### 7. finalizer는 보안 문제도 있다.
finalizer 공격에 노출될 수 있다. 
-> 아무 일도 하지 않는 finalize 메서드를 만들고 final 선언하자.


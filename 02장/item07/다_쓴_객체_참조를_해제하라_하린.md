## item07: 다 쓴 객체 참조를 해제하라.

## 목차
1. Java의 메모리 관리 필요성
2. 다 쓴 참조 
3. 캐시 및 리스너와 콜백


<br/>

## 1. Java의 메모리 관리 필요성

Java는 C, C++ 언어와 다르게 **가비지 컬렉션**이 알아서 메모리를 회수하여 메모리 관리를 하지 않아도 된다고 오해할 수 있다. 하지만 **메모리 누수**가 발생하여 문제가 발생할 수 있다.

메모리 누수 발생 시, 가비지 컬렉션 활동, 메모리 사용량이 늘어나 성능 저하를 일으킬 수 있다. 심한 경우 디스크 페이징이나 OOM이 발생하여 프로그램이 종료될 수도 있다. 

`디스크 페이징`이란 RAM이 부족할 때 디스크를 이용하여 메모리를 확장하는 기술이다. 
`OOM(OutOfMemory) 에러`는 프로그램이 사용가능한 메모리를 모두 소진하였을 경우 발생하는 에러이다. 예를 들어 너무 큰 데이터(대형 파일 읽기..)를 로드하였을 경우 메모리 부족으로 발생할 수 있다. 

<br/>

## 2. 다 쓴 참조

```java
public class Stack {
	private Object[] elements;
	private int size;
	private static final int DEFAULT_INITIAL_CAPACITY = 16;
	
	public Stack() {
		elements = new Object[DEFAULT_INITIAL_CAPACITY];
	}
	
	public void push(Object e) {
		elements[size++] = e;
	}
	
	public Object pop() {
		if(size == 0) throw new EmptyStackException();
		return elements[size--];
	}
}
```
위 예시 코드는 메모리 누수가 발생할 수 있는 코드이다. Object 참조형 배열로 선언하고, push 와 pop을 반복해 원소를 넣었다 뺄 수 있는 Stack 클래스이다. 메모리 누수는 어디에서 일어날까?

바로 pop() 함수에서 발생한다. Stack에서 원소를 pop 할 때 `elements[size--]` 코드를 실행시켜 elements[size] 를 return 하고 size를 감소시키게 된다. 하지만 코드를 위처럼 작성할 경우, 가비지 컬렉터가 pop 한 원소 객체의 메모리를 회수하지 않게 된다. 

<br/>

size가 8인 Object 배열을 만든다고 가정해보자. Object 배열은 기본형과 다르게 선언 시 모든 값이 `null`로 초기화된다. 

> Object[] elements = new [8];

이후 push() 메서드를 통해 인덱스 0부터 6까지 값을 0부터 증가시켜 배열에 차례로 대입한다.

> [0, 1, 2, 3, 4, 5, 6, **null**]

pop() 메서드를 실행한다.

> 6을 반환  
> [0, 1, 2, 3, 4, 5, **6, null**] 

elements 배열의 인덱스 6은 더 이상 사용하지 않지만 참조되어 있는 상태이다. 가비지 컬렉터는 참조되어 있는 변수를 메모리 회수의 대상으로 여기지 않아 메모리 회수가 되지 않는다. 즉 쓰지 않는 객체로 인해 메모리를 차지 하게 되고 이를 **다 쓴 참조** 라고 부른다. 

만약 객체 참조 하나를 살려두면 가비지 컬렉터는 그 객체가 참조하는 모든 객체를 회수하지 못한다. 단 몇 개의 객체가 매우 많은 객체를 회수하지 못하게 할 수 있고, 잠재적으로 성능에 악영향을 줄 수 있다.

<br/>

### 다 쓴 참조 해결법

메모리 누수를 일으킬 수 있는 다 쓴 참조를 어떻게 해결할 수 있을까? 

<br/>

> 다 쓴 참조를 null 처리하자!

비활성 영역의 객체(위에서 언급한 elements 배열에서 인덱스 6~7을 말한다.)가 쓸모 없는 것은 프로그래머만 아는 사실이기 때문에 프로그래머는 비활성 영역이 되는 순간 **null 처리**해서 해당 객체를 더 쓰지 않을 것임을 가비지 컬렉터에 알려야한다. 

```java
public Object pop() {
	if(size == 0) throw new EmptyStackException();
	Object result = elements[--size];
	elements[size] = null; // 다 쓴 객체 참조 해제 
	return result;
}
```
이전 코드에서 `elements[size] = null;` 코드를 추가했다. 다 쓴 객체 참조를 해제하기 위해 pop 대상 객체를 null 처리해준다. 이를 통해 가비지 컬렉터가 메모리 회수를 할 수 있으며, null 처리한 참조를 실수로 사용하게 될 경우 `NullPointerException`을 발생시켜 오류를 사전에 방지할 수 있다.

> 유효 범위 밖으로 변수를 밀어내자.

객체 참조를 null로 처리하는 일은 예외적이어야 한다. null로 처리하지 않는다면 어떻게 다 쓴 참조를 해결할 수 있을까? 바로 참조를 담은 변수를 유효 범위 밖으로 밀어내면 된다. `유효 범위 (스코프)`는 변수가 사용될 수 있는 코드의 영역으로 메소드 내부, 클래스 내부 등이 있다. 유효 범위 밖으로 밀어낸다는 것은 변수가 더 이상 접근할 수 없는 상태가 되어, 가비지 컬렉터가 자동으로 객체 메모리를 회수할 수 있도록 만든다는 뜻이다. 

```java
// chatGPT 참고 
public void someMethod() {
    MyClass obj = new MyClass(); // obj가 MyClass 객체를 참조
} // 메서드가 종료되며 obj의 유효 범위가 끝나고, 객체도 GC의 대상이 된다. 
```

obj는 someMethod() 메서드 내부에서 선언된 지역 변수이다. 메서드가 종료되면 obj의 유효 범위도 끝나므로, obj를 더 이상 참조할 수 없게 된다. 이렇게 되면 GC가 obj가 가리키던 객체를 자동으로 회수할 수 있게 된다. 즉, 변수를 명시적으로 null로 설정하지 않아도 유효 범위가 끝나면서 자연스럽게 더 이상 접근할 수 없게 되는 것을 말한다. (?)

<br/>

## 캐시 및 리스너와 콜백

### 캐시
캐시 역시 메모리 누수를 일으키는 주범이다. 캐시는 자주 사용하는 데이터를 메모리에 저장해두고, 그 데이터를 다시 사용할 수 있도록 한다. 캐시에 넣은 객체를 더 이상 사용하지 않아도 계속해서 캐시에 넣어두면 GC가 객체 메모리를 회수하지 못해 메모리 누수가 발생할 수 있다.

만약 캐시 외부에서 키를 참조하는 동안만 엔트리가 살아있는 캐시가 필요한 상황이라면, `WeakHashMap`을 사용해 캐시를 만들자.

일반적으로 `HashMap`에서 키와 값은 강한 참조로 연결되어 키가 사용되지 않더라도 메모리에서 지워지지 않고 계속 유지된다. 반면에 `WeakHashMap`은 키를 약한 참조로 관리한다. 이 때문에 키 객체가 더 이상 사용되지 않으면, 객체는 자동으로 GC 대상이 되고 제거된다.

캐시 엔트리의 유효 기간을 정확히 정의하기 어렵기 때문에 시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식을 흔히 사용한다. Scheduled ThreadPoolExecutor 같은 백그라운드 스레드를 활용하거나 캐시에 새 엔트리를 추가할 때 부수 작업으로 수행한다.  

`LinkedHashMap`은 엔트리의 순서를 유지하는 Map 자료구조이다. removeEldestEntry() 메서드를 사용하여 가장 오래된 엔트리를 제거할 수 있다

<br/>

### 리스너 혹은 콜백
리스너 혹은 콜백은 비동기 작업이 완료된 후 호출될 함수를 등록하는 방식이다. 예를 들어 버튼 클릭시 호출될 함수, 파일 다운로드가 완료되었을 때 호출될 함수 등이 콜백에 해당된다. 

클라이언트가 콜백을 등록만 하고 해지하지 않으면 콜백은 계속해서 메모리 상에 남아있게 된다. 이 때 콜백을 약한 참조로 저장하면 가비지 컬렉터가 즉시 수거해간다. 예를 들어 WeakHashMap에 키로 저장하면 된다. 




## item07: 다 쓴 객체 참조를 해제하라.

<br/>

### java도 메모리 관리를 해야한다.

```java
public class Stack {
	private Object[] elements;
	private int size;
	private static final int DEFAULT_INITIAL_CAPACITY = 16;
	
	public Stack() {
		elements = new Object[DEFAULT_INITIAL_CAPACITY];
	}
	
	public void push(Object e) {
		elements[size++] = e;
	}
	
	public Object pop() {
		if(size == 0) throw new EmptyStackException();
		return elements[size--];
	}
}
```
- Java는 가비지 컬렉션이 알아서 메모리를 회수하기 때문에 신경 쓰지 않아도 된다고 오해할 수 있다.
- 하지만 위 코드와 같은 코드로 **메모리 누수** 가 발생하여 문제가 발생할 수 있다. 
    - 가비지 컬렉션 활동, 메모리 사용량이 늘어나 결국 성능 저하 발생
    - 심한 경우 디스크 페이징이나 OOM이 발생하여 프로그램 종료될 수 있음.

<br/>

- 디스크 페이징: RAM이 부족할 때 디스크를 이용하여 메모리를 확장하는 기술
- OOM(OutOfMemory) 에러: 프로그램이 사용 가능한 메모리를 모두 소진하였을 경우 발생 
    - 너무 큰 데이터 로드 (대형 파일 읽기, 메모리 부족, ... )

<br/>

### 다 쓴 참조
- 메모리 누수 발생 위치 : Stack 에서 원소를 pop 할 때 pop 한 원소를 가비지 컬렉터가 회수하지 않는다.

<br/>

1. 크기가 8인 Object 배열을 선언한다. 

2. (편의상 인덱스를 1부터 시작이라 가정) 인덱스 1부터 7까지 값을 대입함.  
[1, 2, 3, 4, 5, 6, 7, **null**]

3. pop을 실행한다.  
[1, 2, 3, 4, 5, 6, **7, null**] 
4. 인덱스 7은 다 쓴 참조를 가지고 있다.

#### 다 쓴 참조란?
- 다시 쓰지 않을 참조를 뜻한다. 
- 프로그램은 다시 pop 한 객체를 사용하진 않지만, 배열이 계속 7을 참조하여 가비지 컬렉션이 이 객체를 제거하지 못해 메모리를 차지하게 된다. 
- (책) 스택에서 꺼내진 객체들을 가비지 컬렉턱라 회수하지 않는다. 프로그램에서 그 객체들을 더 이상 사용하지 않더라도 말이다. 

<br/>

### 다 쓴 참조의 악영향
- 객체 참조 하나를 살려두면 가비지 컬렉터는 그 객체가 참조하는 모든 객체를 회수하지 못한다.
- 단 몇 개의 객체가 매우 많은 객체를 회수하지 못하게 할 수 있고, 잠재적으로 성능에 악영향을 줄 수 있다. 

<br/>

### 다 쓴 참조 해결법
#### 1. 다 쓴 참조를 null 처리 한다.
- 비활성 영역의 객체가 쓸모 없는 것은 프로그래머만 아는 사실이기 때문에 프로그래머는 비활성 영역이 되는 순간 null 처리해서 해당 객체를 더 쓰지 않을 것임을 가비지 컬렉터에 알려야 한다. 

<br/>

```java
public Object pop() {
	if(size == 0) throw new EmptyStackException();
	Object result = elements[--size];
	elements[size] = null; // 다 쓴 객체 참조 해제 
	return result;
}
```
- 가비지 컬렉터가 메모리 회수를 할 수 있다. 
- 또한, null 처리한 참조를 실수로 사용하게 될 경우 `NullPointerException`을 발생 시켜 오류를 사전에 방지할 수 있다. 

<br/>

#### 2. 유효 범위 밖으로 변수를 밀어내자.
- 객체 참초를 null로 처리하는 일은 예외적이어야 한다. 
- 참조를 담은 변수를 유효 범위 밖으로 밀어내자.
    - 변수가 유효 범위를 벗어나면 가비지 컬렉터가 자동으로 객체 메모리를 회수한다.
- **유효범위 (스코프)** : 변수가 사용될 수 있는 코드의 영역
    - 메소드 내부, 블록 내부, 클래스 내부 등 ... 
    - 변수가 선언된 위치에 따라 특정 범위 내에서만 접근될 수 있고, 범위 밖으로 나가면 더 이상 그 변수를 사용할 수 없다.

<br/>

### 캐시
- 캐시 역시 메모리 누수를 일으키는 주범이다.
    - **캐시**: 자주 사용하는 데이터를 메모리에 저장해두고, 그 데이터를 다시 사용할 수 있도록 한다.
- 캐시에 넣은 객체를 더 이상 사용하지 않아도 계속해서 캐시에 넣어두면 가비지 컬렉터가 객체 메모리를 회수하지 못해 메모리 누수가 발생할 수 있다. 

<br/>

### 캐시 해결법
캐시 외부에서 키를 참조하는 동안만 엔트리가 살아있는 캐시가 필요한 상황이라면, WeakHasahMap을 사용해 캐시를 만들자.

일반적으로 HashMap에서 키와 값은 강한 참조로 연결되어 키가 사용되지 않더라도 메모리에서 지워지지 않고 계속 유지된다. WeakHashMap은 키를 약한 참조로 관리한다. 만약 키 객체가 더 이상 사용되지 않으면, 객체는 자동으로 가비지 컬렉션 대상이 되고 제거된다.

캐시 엔트리의 유효 기간을 정확히 정의하기 어렵기 때문에 시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식을 흔히 사용한다. Scheduled ThreadPoolExecutor 같은 백그라운드 스레드를 활용하거나 캐시에 새 엔트리를 추가할 때 부수 작업으로 수행한다.  

LinkedHashMap은 엔트리의 순서를 유지하는 Map 자료구조이다. removeEldestEntry() 메서드를 사용하여 가장 오래된 엔트리를 제거할 수 있다.

<br/>

### 리스너 혹은 콜백
리스너 혹은 콜백은 비동기 작업이 완료된 후 호출된 함수를 등록하는 방식이다. 예를 들어 버튼 클릭시 호출될 함수, 파일 다운로드가 완료되었을 때 호출될 함수 등이 콜백에 해당된다. 

클라이언트가 콜백을 등록만 하고 해지하지 않으면 콜백은 계속해서 메모리 상에 남아있게 된다. 

이 때 콜백을 약한 참조로 저장하면 가비지 컬렉터가 즉시 수거해간다. 예를 들어 WeakHashMap에 키로 저장하면 된다. 





